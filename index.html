<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sis Silme Efekti</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f172a;
        }
        
        .fog-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            aspect-ratio: 4/3;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            touch-action: none;
            display: block;
        }
        
        .reset-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        .reset-btn:hover {
            transform: scale(1.1) rotate(90deg);
            background: white;
        }
        
        .reset-btn svg {
            width: 20px;
            height: 20px;
            stroke: #1e293b;
            stroke-width: 2;
            fill: none;
        }
    </style>
</head>
<body>
    <div class="fog-container">
        <canvas id="fogCanvas"></canvas>
        <button class="reset-btn" id="resetBtn" title="Sisi Sıfırla">
            <svg viewBox="0 0 24 24">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        </button>
    </div>

    <script>
        var canvas = document.getElementById('fogCanvas');
        
        // Canvas boyutunu ayarla
        function resizeCanvas() {
            var container = canvas.parentElement;
            var rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            initFog();
        }
        
        var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            console.error('WebGL desteklenmiyor!');
        }

        var vertexShaderSource = 
            'attribute vec2 a_position;' +
            'attribute vec2 a_texCoord;' +
            'varying vec2 v_texCoord;' +
            'void main() {' +
            '    gl_Position = vec4(a_position, 0.0, 1.0);' +
            '    v_texCoord = a_texCoord;' +
            '}';

        var fragmentShaderSource = 
            'precision mediump float;' +
            'uniform sampler2D u_fogTexture;' +
            'varying vec2 v_texCoord;' +
            'void main() {' +
            '    float fogValue = texture2D(u_fogTexture, v_texCoord).r;' +
            '    vec3 fogColor = vec3(0.9, 0.9, 0.92);' +
            '    vec3 bgColor = vec3(0.2 + v_texCoord.x * 0.3, 0.3 + v_texCoord.y * 0.2, 0.5);' +
            '    vec3 color = mix(bgColor, fogColor, fogValue);' +
            '    gl_FragColor = vec4(color, 1.0);' +
            '}';

        function createShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader derlenirken hata:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program oluşturulurken hata:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        var positions = new Float32Array([
            -1, -1,  0, 1,
             1, -1,  1, 1,
            -1,  1,  0, 0,
             1,  1,  1, 0
        ]);

        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        var positionLocation = gl.getAttribLocation(program, 'a_position');
        var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
        
        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);

        var fogData;
        var texture = gl.createTexture();

        function initFog() {
            var width = canvas.width;
            var height = canvas.height;
            fogData = new Uint8Array(width * height);

            for (var i = 0; i < fogData.length; i++) {
                fogData[i] = 255;
            }

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, fogData);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }

        resizeCanvas();

        function render() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }
        
        render();

        var isDrawing = false;

        function wipeFog(x, y) {
            var rect = canvas.getBoundingClientRect();
            var pixelX = Math.floor((x - rect.left) * (canvas.width / rect.width));
            var pixelY = Math.floor((y - rect.top) * (canvas.height / rect.height));

            var brushSize = 25;
            
            for (var dy = -brushSize; dy <= brushSize; dy++) {
                for (var dx = -brushSize; dx <= brushSize; dx++) {
                    var distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= brushSize) {
                        var px = pixelX + dx;
                        var py = pixelY + dy;
                        
                        if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                            var index = py * canvas.width + px;
                            
                            var falloff = 1 - (distance / brushSize);
                            var reduction = Math.floor(falloff * 180);
                            fogData[index] = Math.max(0, fogData[index] - reduction);
                        }
                    }
                }
            }

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, canvas.width, canvas.height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, fogData);
        }

        canvas.addEventListener('mousedown', function(e) {
            isDrawing = true;
            wipeFog(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', function(e) {
            if (isDrawing) {
                wipeFog(e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mouseup', function() {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', function() {
            isDrawing = false;
        });

        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            isDrawing = true;
            var touch = e.touches[0];
            wipeFog(touch.clientX, touch.clientY);
        });

        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            if (isDrawing) {
                var touch = e.touches[0];
                wipeFog(touch.clientX, touch.clientY);
            }
        });

        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            isDrawing = false;
        });

        function resetFog() {
            initFog();
        }

        document.getElementById('resetBtn').addEventListener('click', resetFog);
        
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
